name: Create Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (leave empty to read from VERSION file)'
        required: false
        type: string
      trigger_builds:
        description: 'Trigger all build workflows before creating release'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
  push:
    paths:
      - 'VERSION'
    branches:
      - main
      - master

concurrency:
  group: create-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  detect-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      - name: Read version
        id: version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            VERSION="${{ inputs.version }}"
          elif [ -f VERSION ]; then
            VERSION=$(cat VERSION | tr -d '\n\r ')
          else
            echo "Error: VERSION file not found and no version provided"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Detected version: $VERSION"

  trigger-builds:
    needs: detect-version
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && (inputs.trigger_builds == 'true' || inputs.trigger_builds == '')
    permissions:
      actions: write
      contents: read
    outputs:
      workflow_files: ${{ steps.trigger.outputs.workflow_files }}
    steps:
      - name: Debug trigger conditions
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Trigger builds input: ${{ inputs.trigger_builds }}"
          echo "Ref name: ${{ github.ref_name }}"
          echo "Repository: ${{ github.repository }}"
      - name: Trigger all build workflows
        id: trigger
        run: |
          WORKFLOWS=(
            "windows.yml"
            "macos.yml"
            "linux-glibc.yml"
            "linux-musl.yml"
            "debian.yml"
            "ubuntu.yml"
            "android-termux.yml"
          )
          
          TRIGGERED=0
          FAILED=0
          WORKFLOW_FILES=""
          
          for workflow_file in "${WORKFLOWS[@]}"; do
            echo ""
            echo "=== Triggering workflow: $workflow_file ==="
            
            # Get workflow ID from file name
            WORKFLOW_ID=$(gh api repos/${{ github.repository }}/actions/workflows/"$workflow_file" --jq '.id' 2>/dev/null || echo "")
            
            if [ -n "$WORKFLOW_ID" ] && [ "$WORKFLOW_ID" != "null" ]; then
              echo "Found workflow ID: $WORKFLOW_ID"
              # Trigger workflow using API
              if gh api repos/${{ github.repository }}/actions/workflows/$WORKFLOW_ID/dispatches \
                --method POST \
                -f ref="${{ github.ref_name }}" 2>&1; then
                echo "✓ Successfully triggered $workflow_file"
                TRIGGERED=$((TRIGGERED + 1))
                if [ -n "$WORKFLOW_FILES" ]; then
                  WORKFLOW_FILES="${WORKFLOW_FILES} ${workflow_file}"
                else
                  WORKFLOW_FILES="${workflow_file}"
                fi
              else
                echo "✗ Failed to trigger $workflow_file"
                FAILED=$((FAILED + 1))
              fi
            else
              echo "✗ Could not find workflow ID for $workflow_file"
              FAILED=$((FAILED + 1))
            fi
          done
          
          echo ""
          echo "=== Summary ==="
          echo "Successfully triggered: $TRIGGERED workflows"
          echo "Failed: $FAILED workflows"
          echo ""
          echo "Waiting 30 seconds for workflows to start..."
          sleep 30
          echo "You can check the Actions tab to see the triggered workflows."
          
          echo "workflow_files=$WORKFLOW_FILES" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  wait-for-builds:
    needs: [detect-version, trigger-builds]
    runs-on: ubuntu-latest
    if: |
      always() && 
      (github.event_name == 'push' || 
       (github.event_name == 'workflow_dispatch' && 
        (inputs.trigger_builds == 'true' || inputs.trigger_builds == '')))
    permissions:
      actions: read
      contents: read
    steps:
      - name: Wait for build workflows to complete
        run: |
          # Map workflow files to workflow names
          declare -A WORKFLOW_NAMES=(
            ["windows.yml"]="Build Windows (MSYS2)"
            ["macos.yml"]="Build macOS"
            ["linux-glibc.yml"]="Build Linux (glibc)"
            ["linux-musl.yml"]="Build Linux (musl)"
            ["debian.yml"]="Build Debian"
            ["ubuntu.yml"]="Build Ubuntu"
            ["android-termux.yml"]="Build Android (Termux)"
          )
          
          if [ "${{ github.event_name }}" == "push" ]; then
            # For push events, check all workflows
            WORKFLOWS=("windows.yml" "macos.yml" "linux-glibc.yml" "linux-musl.yml" "debian.yml" "ubuntu.yml" "android-termux.yml")
            echo "Waiting for build workflows to complete (triggered by VERSION change)..."
          else
            # For manual triggers, use the workflows that were actually triggered
            TRIGGERED_WORKFLOWS="${{ needs.trigger-builds.outputs.workflow_files }}"
            if [ -z "$TRIGGERED_WORKFLOWS" ]; then
              echo "No workflows were triggered, proceeding immediately"
              exit 0
            fi
            read -ra WORKFLOWS <<< "$TRIGGERED_WORKFLOWS"
            echo "Waiting for manually triggered build workflows to complete..."
          fi
          
          MAX_WAIT=900  # 15 minutes maximum
          POLL_INTERVAL=30  # Check every 30 seconds
          START_TIME=$(date +%s)
          CURRENT_SHA="${{ github.sha }}"
          
          echo "Current commit SHA: $CURRENT_SHA"
          echo "Branch: ${{ github.ref_name }}"
          echo "Repository: ${{ github.repository }}"
          echo ""
          echo "Listing all recent workflow runs on this branch..."
          gh run list --repo="${{ github.repository }}" --branch="${{ github.ref_name }}" --limit=10 --json workflowName,status,conclusion,createdAt,headSha --jq '.[] | "\(.workflowName): \(.status) (\(.conclusion // "none")) - \(.createdAt) - \(.headSha[0:7])"' 2>&1 || echo "Failed to list runs"
          echo ""
          echo "Waiting 60 seconds for triggered workflows to appear in API..."
          # Sleep in small chunks to allow cancellation
          for i in {1..12}; do
            sleep 5
          done
          echo ""
          
          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))
            
            if [ $ELAPSED -ge $MAX_WAIT ]; then
              echo "Timeout reached (${MAX_WAIT}s). Proceeding with available artifacts."
              break
            fi
            
            ALL_COMPLETE=true
            IN_PROGRESS=0
            COMPLETED=0
            FAILED=0
            
            for workflow_file in "${WORKFLOWS[@]}"; do
              WORKFLOW_NAME="${WORKFLOW_NAMES[$workflow_file]}"
              
              # Get the most recent run for this workflow on the current branch
              # Look for runs created in the last 30 minutes (generous window for triggered workflows)
              RUN_STATUS=$(gh run list --repo="${{ github.repository }}" --workflow="$workflow_file" --branch="${{ github.ref_name }}" --limit=20 --json status,conclusion,createdAt --jq ".[] | select(.createdAt | fromdateiso8601 > (now - 1800)) | \"\(.status)|\(.conclusion // \"none\")\"" 2>/dev/null | head -1 || echo "")
              
              # If not found by file name, try by workflow display name
              if [ -z "$RUN_STATUS" ]; then
                RUN_STATUS=$(gh run list --repo="${{ github.repository }}" --workflow="$WORKFLOW_NAME" --branch="${{ github.ref_name }}" --limit=20 --json status,conclusion,createdAt --jq ".[] | select(.createdAt | fromdateiso8601 > (now - 1800)) | \"\(.status)|\(.conclusion // \"none\")\"" 2>/dev/null | head -1 || echo "")
              fi
              
              # If still not found, try without time filter (get most recent run)
              if [ -z "$RUN_STATUS" ]; then
                RUN_STATUS=$(gh run list --repo="${{ github.repository }}" --workflow="$workflow_file" --branch="${{ github.ref_name }}" --limit=1 --json status,conclusion,createdAt --jq '.[0] | if . then "\(.status)|\(.conclusion // "none")" else "none|none" end' 2>/dev/null || echo "none|none")
              fi
              
              
              STATUS=$(echo "$RUN_STATUS" | cut -d'|' -f1)
              CONCLUSION=$(echo "$RUN_STATUS" | cut -d'|' -f2)
              
              if [ "$STATUS" == "completed" ]; then
                if [ "$CONCLUSION" == "success" ]; then
                  echo "  ✓ $workflow_file: completed successfully"
                  COMPLETED=$((COMPLETED + 1))
                else
                  echo "  ✗ $workflow_file: completed with $CONCLUSION"
                  FAILED=$((FAILED + 1))
                fi
              elif [ "$STATUS" == "in_progress" ] || [ "$STATUS" == "queued" ]; then
                echo "  ⏳ $workflow_file: $STATUS"
                IN_PROGRESS=$((IN_PROGRESS + 1))
                ALL_COMPLETE=false
              elif [ "$STATUS" == "none" ] || [ -z "$STATUS" ]; then
                echo "  ? $workflow_file: no recent runs found"
                ALL_COMPLETE=false
              else
                echo "  ? $workflow_file: $STATUS"
                ALL_COMPLETE=false
              fi
            done
            
            echo ""
            echo "Status: $COMPLETED completed, $IN_PROGRESS in progress, $FAILED failed"
            echo "Elapsed: ${ELAPSED}s / ${MAX_WAIT}s"
            
            if [ "$ALL_COMPLETE" == "true" ]; then
              echo ""
              echo "All workflows have completed. Proceeding to collect artifacts."
              break
            fi
            
            echo "Waiting ${POLL_INTERVAL} seconds before next check..."
            # Sleep in small chunks to allow cancellation
            CHUNK_SIZE=5
            ITERATIONS=$((POLL_INTERVAL / CHUNK_SIZE))
            for i in $(seq 1 $ITERATIONS); do
              sleep $CHUNK_SIZE
            done
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  check-release-exists:
    runs-on: ubuntu-latest
    needs: detect-version
    outputs:
      exists: ${{ steps.check.outputs.exists }}
    steps:
      - name: Check if release already exists
        id: check
        run: |
          VERSION="${{ needs.detect-version.outputs.version }}"
          TAG="v${VERSION}"
          if gh release view "$TAG" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Release $TAG already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Release $TAG does not exist yet"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  collect-artifacts:
    needs: [detect-version, wait-for-builds, check-release-exists]
    if: needs.check-release-exists.outputs.exists == 'false'
    runs-on: ubuntu-latest
    permissions:
      actions: read
    steps:
      - name: Find and download artifacts from build workflows
        run: |
          VERSION="${{ needs.detect-version.outputs.version }}"
          mkdir -p artifacts
          
          WORKFLOWS=(
            "Build Windows (MSYS2)"
            "Build macOS"
            "Build Linux (glibc)"
            "Build Linux (musl)"
            "Build Debian"
            "Build Ubuntu"
            "Build Android (Termux)"
          )
          
          # Get current commit SHA to find runs from same commit
          CURRENT_SHA="${{ github.sha }}"
          echo "Looking for artifacts from workflows triggered for commit: $CURRENT_SHA"
          echo ""
          
          for workflow_name in "${WORKFLOWS[@]}"; do
            echo "=== Looking for artifacts from workflow: $workflow_name ==="
            
            # First try to find a run from the same commit
            RUN_ID=$(gh run list --repo="${{ github.repository }}" --workflow="$workflow_name" --branch="${{ github.ref_name }}" --commit="$CURRENT_SHA" --status=success --limit=1 --json databaseId --jq '.[0].databaseId' 2>/dev/null || echo "")
            
            # If not found, try to find the most recent successful run (within last 2 hours)
            if [ -z "$RUN_ID" ] || [ "$RUN_ID" == "null" ]; then
              echo "No run found for commit $CURRENT_SHA, looking for recent successful runs..."
              RUN_ID=$(gh run list --repo="${{ github.repository }}" --workflow="$workflow_name" --branch="${{ github.ref_name }}" --status=success --limit=5 --json databaseId,createdAt,headSha --jq '.[] | select(.createdAt | fromdateiso8601 > (now - 7200)) | .databaseId' 2>/dev/null | head -1 || echo "")
            fi
            
            if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
              echo "Found workflow run ID: $RUN_ID"
              
              # List artifacts from this run
              ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts --jq '.artifacts[] | select(.name | startswith("br-ar-")) | .id' 2>/dev/null || echo "")
              
              if [ -n "$ARTIFACTS" ]; then
                ARTIFACT_NAMES=$(gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts --jq '.artifacts[] | select(.name | startswith("br-ar-")) | .name' 2>/dev/null || echo "")
                echo "Found artifacts: $ARTIFACT_NAMES"
                for artifact_id in $ARTIFACTS; do
                  echo "Downloading artifact ID: $artifact_id"
                  # Use curl to download artifact, following redirects
                  # The API endpoint redirects to a signed download URL
                  curl -L \
                    -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github+json" \
                    -o "artifacts/artifact-$artifact_id.zip" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$artifact_id/zip" || echo "Failed to download artifact $artifact_id"
                done
              else
                echo "No artifacts found in run $RUN_ID"
              fi
            else
              echo "No successful workflow run found for $workflow_name"
            fi
            echo ""
          done
          
          echo ""
          echo "Extracting downloaded artifacts..."
          cd artifacts
          for zip in *.zip; do
            if [ -f "$zip" ]; then
              unzip -q "$zip" -d "extracted-$zip" || true
              rm "$zip"
            fi
          done
          
          # Move files from extracted directories to artifacts root
          find . -type f \( -name "*.tar.gz" -o -name "*.tar.xz" -o -name "*.tar.bz2" -o -name "*.deb" -o -name "*.pkg" \) -exec mv {} . \; 2>/dev/null || true
          rm -rf extracted-* || true
          
          echo ""
          echo "Final artifacts:"
          find . -type f \( -name "*.tar.gz" -o -name "*.tar.xz" -o -name "*.tar.bz2" -o -name "*.deb" -o -name "*.pkg" \) | sort || echo "No artifacts found"
          
          # Count artifacts
          ARTIFACT_COUNT=$(find . -type f \( -name "*.tar.gz" -o -name "*.tar.xz" -o -name "*.tar.bz2" -o -name "*.deb" -o -name "*.pkg" \) 2>/dev/null | wc -l || echo "0")
          echo "Total artifacts collected: $ARTIFACT_COUNT"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload collected artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: collected-release-artifacts
          path: artifacts/
          retention-days: 1

  create-release:
    needs: [detect-version, check-release-exists, collect-artifacts]
    if: needs.check-release-exists.outputs.exists == 'false'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download collected artifacts
        uses: actions/download-artifact@v4
        with:
          name: collected-release-artifacts
          path: artifacts
      - name: List all collected artifacts
        run: |
          echo "Collected artifacts:"
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.tar.xz" -o -name "*.tar.bz2" -o -name "*.deb" -o -name "*.pkg" \) 2>/dev/null | sort || echo "No artifacts found"
          echo ""
          echo "Artifact count:"
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.tar.xz" -o -name "*.tar.bz2" -o -name "*.deb" -o -name "*.pkg" \) 2>/dev/null | wc -l || echo "0"
      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.detect-version.outputs.version }}
          name: Release v${{ needs.detect-version.outputs.version }}
          files: artifacts/**/*
          generate_release_notes: true
          draft: false
          prerelease: false
